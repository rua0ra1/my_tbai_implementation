#include "tbai_mpc/wbc/Task.hpp"

namespace switched_model {

/*********************************************************************************************************************/
/*********************************************************************************************************************/
/*********************************************************************************************************************/
Task Task::operator+(const Task &other) const {
    Task t12(mvstack(this->A, other.A), vvstack(this->b, other.b), mvstack(this->D, other.D),
             vvstack(this->f, other.f));
    return t12;
}

/*********************************************************************************************************************/
/*********************************************************************************************************************/
/*********************************************************************************************************************/
Task Task::operator*(const scalar_t rhs) const {
    return Task(A.cols() > 0 ? A * rhs : A, b.size() > 0 ? b * rhs : b, D.cols() > 0 ? D * rhs : D,
                f.cols() > 0 ? f * rhs : f);
}

/*********************************************************************************************************************/
/*********************************************************************************************************************/
/*********************************************************************************************************************/
std::ostream &operator<<(std::ostream &os, const Task &t) {
    os << "Matrix A: \n" << t.A << "\n";
    os << "Vector b: \n" << t.b << "\n";
    os << "Matrix D: \n" << t.D << "\n";
    os << "Vector f: \n" << t.f << "\n";
    std::flush(os);
    return os;
}

/*********************************************************************************************************************/
/*********************************************************************************************************************/
/*********************************************************************************************************************/
matrix_t mvstack(const matrix_t &m1, const matrix_t &m2) {
    if (m1.cols() == 0) {
        return m2;
    }
    if (m2.cols() == 0) {
        return m1;
    }
    return (matrix_t(m1.rows() + m2.rows(), m1.cols()) << m1, m2).finished();
}

/*********************************************************************************************************************/
/*********************************************************************************************************************/
/*********************************************************************************************************************/
vector_t vvstack(const vector_t &v1, const vector_t &v2) {
    if (v1.cols() == 0) {
        return v2;
    }
    if (v2.cols() == 0) {
        return v1;
    }
    return (vector_t(v1.rows() + v2.rows()) << v1, v2).finished();
}

}  // namespace switched_model
